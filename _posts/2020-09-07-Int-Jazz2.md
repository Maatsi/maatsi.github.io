---
title: "Jazz Networks - Binary tree and List"
tags: [Interview Preparation, Binary Tree, List]
categories:
  - Interview Preparation
date: 2020-09-07
---


## Q - Implement a function that counts the set bit of a binary tree in C.
1. [Binary tree](#what-is-a-binary-tree)  
  1.1 [Binary Search Tree](#binary-search-tree)
2. [Steps and Pseudocode](#steps-and-pseudocode)
3. [Implementation](#implementation)


### 1. What is a Binary Tree?
- A tree whose elements have at most 2 child nodes - the left and the right node.
- Nodes with no children are called 'leaves'.  
- The height h of a complete binary tree with N nodes is at most **O(log N)**.
  > - n = 1 + 2 + 4 + ... + 2<sup>h-1</sup> + 2<sup>h</sup> = 2<sup>h+1</sup> - 1
  > - Solving for h gives **O(log n)**


| Complete tree | Full Tree |
|-------------- | --------- |
| A tree that is completely filled, except for the bottom level, which is filled from left to right. | Binary tree in which each node has exactly zero or two children |
| ![Screenshot 2020-09-08 at 10 19 55 am](https://user-images.githubusercontent.com/33334078/92423656-d8b35b00-f1bc-11ea-8a2e-7f2c0be24907.png) | ![Screenshot 2020-09-08 at 10 20 08 am](https://user-images.githubusercontent.com/33334078/92423669-e072ff80-f1bc-11ea-8a8a-2786f6e10ff5.png) |


#### Binary Search Tree
- Each node contains **one** key (also known as data)
- The keys in the **left subtree are less then the key in its parent node**, in short L < P;
  - 10 > 6, 4, 8
- The keys in the **right subtree are greater the key in its parent node**, in short P < R;
  - 10 < 18, 15, 21
- ![image](https://user-images.githubusercontent.com/33334078/92438810-81c17c00-f1e4-11ea-8572-29d99837b1e5.png)



#### Steps and Pseudocode
##### Example  

| Input | Input in Binary | Result |  
| ----- | ------ | ------ |
|![1](https://user-images.githubusercontent.com/33334078/93730142-525a3880-fc02-11ea-956e-43fd025265b8.png) | ![2](https://user-images.githubusercontent.com/33334078/93730145-55edbf80-fc02-11ea-8087-1b2fba11ac2a.png) | **9** |  



##### Algorithm 1. Tree traversal
- Traverse the tree from the root, to the left and the right sub-tree (Pre-order - root, left, right)
- **Steps**
  1. Visit the root
  2. Traverse the left subtree  
  3. Traverse the right subtree


###### Code
```
/* A binary tree node has data, pointer to left child
   and a pointer to right child */

struct node_t { 
  uint8_t data; 
  struct node_t *left; 
  struct node_t  *right;
 }; 

void pre_order_traversal(struct node* root) {
  if (root != NULL)
    pre_order_traversal(root->left)
    pre_order_traversal(root->right)
```


##### Algorithm 2. Check set bits
  - Check if the last bit is odd.
    - if odd then ans+1
  - Shift the bits to the right
  - Shift until the end of the bits

###### Code
```

int count_bits(struct node_t *n){
  uint8_t data = n->data; 
  int count = 0;

  // bc its unsigned int 8 hence 8 bits (1byte) (range = 0 to 255)
  for (int i = 0; i <= 8; i++){
    // check if last bit is odd ( bc its always +1)
    if (int i % 2 == 1) {
      count +=1
    }
    // then shift one bit
    i >> 1

    return count;
  }

```



##Code

struct node_t { 
  uint8_t data; 
  struct node_t *left; 
  struct node_t  *right;
 }; 

void pre_order_traversal(struct node* root) {
  // set the count variable for each subtree
  int root_count, left_count, right_count = 0;

  if (root != NULL)
    root_count = count_bits(root);
    left_count = count_bits(root->left);
    right_count = count_bits(root->right);

  return root_count+left_count+right_count;


int count_bits(struct node_t *n){
  uint8_t data = n->data; 
  int count = 0;

  // bc its unsigned int 8 hence 8 bits (1byte) (range = 0 to 255)
  for (int i = 0; i <= 8; i++){
    // check if last bit is odd ( bc its always +1)
    if (int i % 2 == 1) {
      count +=1
    }
    // then shift one bit
    i >> 1

    return count;
  }



! key
- bitshiftitng  

- Tree insertion source code [link](https://www.tutorialspoint.com/data_structures_algorithms/tree_traversal_in_c.htm)
